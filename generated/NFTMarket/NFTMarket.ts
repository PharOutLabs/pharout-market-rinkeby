// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class FundsForwarded extends ethereum.Event {
  get params(): FundsForwarded__Params {
    return new FundsForwarded__Params(this);
  }
}

export class FundsForwarded__Params {
  _event: FundsForwarded;

  constructor(event: FundsForwarded) {
    this._event = event;
  }

  get value(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get from(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class ItemBought extends ethereum.Event {
  get params(): ItemBought__Params {
    return new ItemBought__Params(this);
  }
}

export class ItemBought__Params {
  _event: ItemBought;

  constructor(event: ItemBought) {
    this._event = event;
  }

  get itemId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get tokenId(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get nftContract(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get fromAddress(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get toAddress(): Address {
    return this._event.parameters[4].value.toAddress();
  }
}

export class ItemDelisted extends ethereum.Event {
  get params(): ItemDelisted__Params {
    return new ItemDelisted__Params(this);
  }
}

export class ItemDelisted__Params {
  _event: ItemDelisted;

  constructor(event: ItemDelisted) {
    this._event = event;
  }

  get itemId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get tokenId(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get nftContract(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class ItemListed extends ethereum.Event {
  get params(): ItemListed__Params {
    return new ItemListed__Params(this);
  }
}

export class ItemListed__Params {
  _event: ItemListed;

  constructor(event: ItemListed) {
    this._event = event;
  }

  get itemId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get amount1155(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get price(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get tokenId(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get nftContract(): Address {
    return this._event.parameters[4].value.toAddress();
  }

  get seller(): Address {
    return this._event.parameters[5].value.toAddress();
  }
}

export class ItemUpdated extends ethereum.Event {
  get params(): ItemUpdated__Params {
    return new ItemUpdated__Params(this);
  }
}

export class ItemUpdated__Params {
  _event: ItemUpdated;

  constructor(event: ItemUpdated) {
    this._event = event;
  }

  get itemId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get tokenId(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get price(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get nftContract(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get seller(): Address {
    return this._event.parameters[4].value.toAddress();
  }
}

export class NFTMarket__fetchItemsBySellerResultValue0Struct extends ethereum.Tuple {
  get is1155(): boolean {
    return this[0].toBoolean();
  }

  get itemId(): BigInt {
    return this[1].toBigInt();
  }

  get amount1155(): BigInt {
    return this[2].toBigInt();
  }

  get price(): BigInt {
    return this[3].toBigInt();
  }

  get tokenId(): BigInt {
    return this[4].toBigInt();
  }

  get nftContract(): Address {
    return this[5].toAddress();
  }

  get seller(): Address {
    return this[6].toAddress();
  }
}

export class NFTMarket__fetchMarketItemsResultValue0Struct extends ethereum.Tuple {
  get is1155(): boolean {
    return this[0].toBoolean();
  }

  get itemId(): BigInt {
    return this[1].toBigInt();
  }

  get amount1155(): BigInt {
    return this[2].toBigInt();
  }

  get price(): BigInt {
    return this[3].toBigInt();
  }

  get tokenId(): BigInt {
    return this[4].toBigInt();
  }

  get nftContract(): Address {
    return this[5].toAddress();
  }

  get seller(): Address {
    return this[6].toAddress();
  }
}

export class NFTMarket extends ethereum.SmartContract {
  static bind(address: Address): NFTMarket {
    return new NFTMarket("NFTMarket", address);
  }

  BIDS(): Bytes {
    let result = super.call("BIDS", "BIDS():(bytes32)", []);

    return result[0].toBytes();
  }

  try_BIDS(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("BIDS", "BIDS():(bytes32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  DEV(): Bytes {
    let result = super.call("DEV", "DEV():(bytes32)", []);

    return result[0].toBytes();
  }

  try_DEV(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("DEV", "DEV():(bytes32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  NFTADD(): Bytes {
    let result = super.call("NFTADD", "NFTADD():(bytes32)", []);

    return result[0].toBytes();
  }

  try_NFTADD(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("NFTADD", "NFTADD():(bytes32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  OFFERS(): Bytes {
    let result = super.call("OFFERS", "OFFERS():(bytes32)", []);

    return result[0].toBytes();
  }

  try_OFFERS(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("OFFERS", "OFFERS():(bytes32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  PROXY_ROLE(): Bytes {
    let result = super.call("PROXY_ROLE", "PROXY_ROLE():(bytes32)", []);

    return result[0].toBytes();
  }

  try_PROXY_ROLE(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("PROXY_ROLE", "PROXY_ROLE():(bytes32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  REWARDS(): Bytes {
    let result = super.call("REWARDS", "REWARDS():(bytes32)", []);

    return result[0].toBytes();
  }

  try_REWARDS(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("REWARDS", "REWARDS():(bytes32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  TRADES(): Bytes {
    let result = super.call("TRADES", "TRADES():(bytes32)", []);

    return result[0].toBytes();
  }

  try_TRADES(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("TRADES", "TRADES():(bytes32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  addressToUserBal(param0: Address): BigInt {
    let result = super.call(
      "addressToUserBal",
      "addressToUserBal(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBigInt();
  }

  try_addressToUserBal(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "addressToUserBal",
      "addressToUserBal(address):(uint256)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  delistMarketItems(itemId: Array<BigInt>): boolean {
    let result = super.call(
      "delistMarketItems",
      "delistMarketItems(uint256[]):(bool)",
      [ethereum.Value.fromUnsignedBigIntArray(itemId)]
    );

    return result[0].toBoolean();
  }

  try_delistMarketItems(itemId: Array<BigInt>): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "delistMarketItems",
      "delistMarketItems(uint256[]):(bool)",
      [ethereum.Value.fromUnsignedBigIntArray(itemId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  fetchAmountListed(userAdd: Address): BigInt {
    let result = super.call(
      "fetchAmountListed",
      "fetchAmountListed(address):(uint256)",
      [ethereum.Value.fromAddress(userAdd)]
    );

    return result[0].toBigInt();
  }

  try_fetchAmountListed(userAdd: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "fetchAmountListed",
      "fetchAmountListed(address):(uint256)",
      [ethereum.Value.fromAddress(userAdd)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  fetchItemsBySeller(
    userAdd: Address
  ): Array<NFTMarket__fetchItemsBySellerResultValue0Struct> {
    let result = super.call(
      "fetchItemsBySeller",
      "fetchItemsBySeller(address):((bool,uint256,uint256,uint256,uint256,address,address)[])",
      [ethereum.Value.fromAddress(userAdd)]
    );

    return result[0].toTupleArray<
      NFTMarket__fetchItemsBySellerResultValue0Struct
    >();
  }

  try_fetchItemsBySeller(
    userAdd: Address
  ): ethereum.CallResult<
    Array<NFTMarket__fetchItemsBySellerResultValue0Struct>
  > {
    let result = super.tryCall(
      "fetchItemsBySeller",
      "fetchItemsBySeller(address):((bool,uint256,uint256,uint256,uint256,address,address)[])",
      [ethereum.Value.fromAddress(userAdd)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTupleArray<NFTMarket__fetchItemsBySellerResultValue0Struct>()
    );
  }

  fetchMarketItems(): Array<NFTMarket__fetchMarketItemsResultValue0Struct> {
    let result = super.call(
      "fetchMarketItems",
      "fetchMarketItems():((bool,uint256,uint256,uint256,uint256,address,address)[])",
      []
    );

    return result[0].toTupleArray<
      NFTMarket__fetchMarketItemsResultValue0Struct
    >();
  }

  try_fetchMarketItems(): ethereum.CallResult<
    Array<NFTMarket__fetchMarketItemsResultValue0Struct>
  > {
    let result = super.tryCall(
      "fetchMarketItems",
      "fetchMarketItems():((bool,uint256,uint256,uint256,uint256,address,address)[])",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTupleArray<NFTMarket__fetchMarketItemsResultValue0Struct>()
    );
  }

  itemIds(): BigInt {
    let result = super.call("itemIds", "itemIds():(uint256)", []);

    return result[0].toBigInt();
  }

  try_itemIds(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("itemIds", "itemIds():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  listMarketItems(
    is1155: Array<boolean>,
    amount1155: Array<BigInt>,
    tokenId: Array<BigInt>,
    price: Array<BigInt>,
    nftContract: Array<Address>
  ): boolean {
    let result = super.call(
      "listMarketItems",
      "listMarketItems(bool[],uint256[],uint256[],uint256[],address[]):(bool)",
      [
        ethereum.Value.fromBooleanArray(is1155),
        ethereum.Value.fromUnsignedBigIntArray(amount1155),
        ethereum.Value.fromUnsignedBigIntArray(tokenId),
        ethereum.Value.fromUnsignedBigIntArray(price),
        ethereum.Value.fromAddressArray(nftContract)
      ]
    );

    return result[0].toBoolean();
  }

  try_listMarketItems(
    is1155: Array<boolean>,
    amount1155: Array<BigInt>,
    tokenId: Array<BigInt>,
    price: Array<BigInt>,
    nftContract: Array<Address>
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "listMarketItems",
      "listMarketItems(bool[],uint256[],uint256[],uint256[],address[]):(bool)",
      [
        ethereum.Value.fromBooleanArray(is1155),
        ethereum.Value.fromUnsignedBigIntArray(amount1155),
        ethereum.Value.fromUnsignedBigIntArray(tokenId),
        ethereum.Value.fromUnsignedBigIntArray(price),
        ethereum.Value.fromAddressArray(nftContract)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  minVal(): BigInt {
    let result = super.call("minVal", "minVal():(uint256)", []);

    return result[0].toBigInt();
  }

  try_minVal(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("minVal", "minVal():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  onERC1155Received(
    param0: Address,
    param1: Address,
    param2: BigInt,
    param3: BigInt,
    param4: Bytes
  ): Bytes {
    let result = super.call(
      "onERC1155Received",
      "onERC1155Received(address,address,uint256,uint256,bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
        ethereum.Value.fromUnsignedBigInt(param3),
        ethereum.Value.fromBytes(param4)
      ]
    );

    return result[0].toBytes();
  }

  try_onERC1155Received(
    param0: Address,
    param1: Address,
    param2: BigInt,
    param3: BigInt,
    param4: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "onERC1155Received",
      "onERC1155Received(address,address,uint256,uint256,bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
        ethereum.Value.fromUnsignedBigInt(param3),
        ethereum.Value.fromBytes(param4)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  onERC721Received(
    param0: Address,
    param1: Address,
    param2: BigInt,
    param3: Bytes
  ): Bytes {
    let result = super.call(
      "onERC721Received",
      "onERC721Received(address,address,uint256,bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
        ethereum.Value.fromBytes(param3)
      ]
    );

    return result[0].toBytes();
  }

  try_onERC721Received(
    param0: Address,
    param1: Address,
    param2: BigInt,
    param3: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "onERC721Received",
      "onERC721Received(address,address,uint256,bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
        ethereum.Value.fromBytes(param3)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  roleAdd(): Address {
    let result = super.call("roleAdd", "roleAdd():(address)", []);

    return result[0].toAddress();
  }

  try_roleAdd(): ethereum.CallResult<Address> {
    let result = super.tryCall("roleAdd", "roleAdd():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  setMinimumValue(minWei: BigInt): boolean {
    let result = super.call(
      "setMinimumValue",
      "setMinimumValue(uint256):(bool)",
      [ethereum.Value.fromUnsignedBigInt(minWei)]
    );

    return result[0].toBoolean();
  }

  try_setMinimumValue(minWei: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "setMinimumValue",
      "setMinimumValue(uint256):(bool)",
      [ethereum.Value.fromUnsignedBigInt(minWei)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  transferNftForSale(receiver: Address, itemId: BigInt): boolean {
    let result = super.call(
      "transferNftForSale",
      "transferNftForSale(address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(receiver),
        ethereum.Value.fromUnsignedBigInt(itemId)
      ]
    );

    return result[0].toBoolean();
  }

  try_transferNftForSale(
    receiver: Address,
    itemId: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "transferNftForSale",
      "transferNftForSale(address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(receiver),
        ethereum.Value.fromUnsignedBigInt(itemId)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  withdrawToken(
    receiver: Address,
    tokenContract: Address,
    amount: BigInt
  ): boolean {
    let result = super.call(
      "withdrawToken",
      "withdrawToken(address,address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(receiver),
        ethereum.Value.fromAddress(tokenContract),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );

    return result[0].toBoolean();
  }

  try_withdrawToken(
    receiver: Address,
    tokenContract: Address,
    amount: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "withdrawToken",
      "withdrawToken(address,address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(receiver),
        ethereum.Value.fromAddress(tokenContract),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get newrole(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class BuyMarketItemsCall extends ethereum.Call {
  get inputs(): BuyMarketItemsCall__Inputs {
    return new BuyMarketItemsCall__Inputs(this);
  }

  get outputs(): BuyMarketItemsCall__Outputs {
    return new BuyMarketItemsCall__Outputs(this);
  }
}

export class BuyMarketItemsCall__Inputs {
  _call: BuyMarketItemsCall;

  constructor(call: BuyMarketItemsCall) {
    this._call = call;
  }

  get itemId(): Array<BigInt> {
    return this._call.inputValues[0].value.toBigIntArray();
  }
}

export class BuyMarketItemsCall__Outputs {
  _call: BuyMarketItemsCall;

  constructor(call: BuyMarketItemsCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class DelistMarketItemsCall extends ethereum.Call {
  get inputs(): DelistMarketItemsCall__Inputs {
    return new DelistMarketItemsCall__Inputs(this);
  }

  get outputs(): DelistMarketItemsCall__Outputs {
    return new DelistMarketItemsCall__Outputs(this);
  }
}

export class DelistMarketItemsCall__Inputs {
  _call: DelistMarketItemsCall;

  constructor(call: DelistMarketItemsCall) {
    this._call = call;
  }

  get itemId(): Array<BigInt> {
    return this._call.inputValues[0].value.toBigIntArray();
  }
}

export class DelistMarketItemsCall__Outputs {
  _call: DelistMarketItemsCall;

  constructor(call: DelistMarketItemsCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class ListMarketItemsCall extends ethereum.Call {
  get inputs(): ListMarketItemsCall__Inputs {
    return new ListMarketItemsCall__Inputs(this);
  }

  get outputs(): ListMarketItemsCall__Outputs {
    return new ListMarketItemsCall__Outputs(this);
  }
}

export class ListMarketItemsCall__Inputs {
  _call: ListMarketItemsCall;

  constructor(call: ListMarketItemsCall) {
    this._call = call;
  }

  get is1155(): Array<boolean> {
    return this._call.inputValues[0].value.toBooleanArray();
  }

  get amount1155(): Array<BigInt> {
    return this._call.inputValues[1].value.toBigIntArray();
  }

  get tokenId(): Array<BigInt> {
    return this._call.inputValues[2].value.toBigIntArray();
  }

  get price(): Array<BigInt> {
    return this._call.inputValues[3].value.toBigIntArray();
  }

  get nftContract(): Array<Address> {
    return this._call.inputValues[4].value.toAddressArray();
  }
}

export class ListMarketItemsCall__Outputs {
  _call: ListMarketItemsCall;

  constructor(call: ListMarketItemsCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class OnERC1155ReceivedCall extends ethereum.Call {
  get inputs(): OnERC1155ReceivedCall__Inputs {
    return new OnERC1155ReceivedCall__Inputs(this);
  }

  get outputs(): OnERC1155ReceivedCall__Outputs {
    return new OnERC1155ReceivedCall__Outputs(this);
  }
}

export class OnERC1155ReceivedCall__Inputs {
  _call: OnERC1155ReceivedCall;

  constructor(call: OnERC1155ReceivedCall) {
    this._call = call;
  }

  get value0(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get value1(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get value2(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get value3(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get value4(): Bytes {
    return this._call.inputValues[4].value.toBytes();
  }
}

export class OnERC1155ReceivedCall__Outputs {
  _call: OnERC1155ReceivedCall;

  constructor(call: OnERC1155ReceivedCall) {
    this._call = call;
  }

  get value0(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class SetMinimumValueCall extends ethereum.Call {
  get inputs(): SetMinimumValueCall__Inputs {
    return new SetMinimumValueCall__Inputs(this);
  }

  get outputs(): SetMinimumValueCall__Outputs {
    return new SetMinimumValueCall__Outputs(this);
  }
}

export class SetMinimumValueCall__Inputs {
  _call: SetMinimumValueCall;

  constructor(call: SetMinimumValueCall) {
    this._call = call;
  }

  get minWei(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class SetMinimumValueCall__Outputs {
  _call: SetMinimumValueCall;

  constructor(call: SetMinimumValueCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferNftForSaleCall extends ethereum.Call {
  get inputs(): TransferNftForSaleCall__Inputs {
    return new TransferNftForSaleCall__Inputs(this);
  }

  get outputs(): TransferNftForSaleCall__Outputs {
    return new TransferNftForSaleCall__Outputs(this);
  }
}

export class TransferNftForSaleCall__Inputs {
  _call: TransferNftForSaleCall;

  constructor(call: TransferNftForSaleCall) {
    this._call = call;
  }

  get receiver(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get itemId(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class TransferNftForSaleCall__Outputs {
  _call: TransferNftForSaleCall;

  constructor(call: TransferNftForSaleCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class UpdateMarketItemPriceCall extends ethereum.Call {
  get inputs(): UpdateMarketItemPriceCall__Inputs {
    return new UpdateMarketItemPriceCall__Inputs(this);
  }

  get outputs(): UpdateMarketItemPriceCall__Outputs {
    return new UpdateMarketItemPriceCall__Outputs(this);
  }
}

export class UpdateMarketItemPriceCall__Inputs {
  _call: UpdateMarketItemPriceCall;

  constructor(call: UpdateMarketItemPriceCall) {
    this._call = call;
  }

  get itemId(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get price(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class UpdateMarketItemPriceCall__Outputs {
  _call: UpdateMarketItemPriceCall;

  constructor(call: UpdateMarketItemPriceCall) {
    this._call = call;
  }
}

export class WithdrawTokenCall extends ethereum.Call {
  get inputs(): WithdrawTokenCall__Inputs {
    return new WithdrawTokenCall__Inputs(this);
  }

  get outputs(): WithdrawTokenCall__Outputs {
    return new WithdrawTokenCall__Outputs(this);
  }
}

export class WithdrawTokenCall__Inputs {
  _call: WithdrawTokenCall;

  constructor(call: WithdrawTokenCall) {
    this._call = call;
  }

  get receiver(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get tokenContract(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class WithdrawTokenCall__Outputs {
  _call: WithdrawTokenCall;

  constructor(call: WithdrawTokenCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}
