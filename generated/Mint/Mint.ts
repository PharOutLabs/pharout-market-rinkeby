// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class NFTCountAdded extends ethereum.Event {
  get params(): NFTCountAdded__Params {
    return new NFTCountAdded__Params(this);
  }
}

export class NFTCountAdded__Params {
  _event: NFTCountAdded;

  constructor(event: NFTCountAdded) {
    this._event = event;
  }

  get param0(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class RedeemTokenSet extends ethereum.Event {
  get params(): RedeemTokenSet__Params {
    return new RedeemTokenSet__Params(this);
  }
}

export class RedeemTokenSet__Params {
  _event: RedeemTokenSet;

  constructor(event: RedeemTokenSet) {
    this._event = event;
  }

  get contractAddress(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get redeemId(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class nftClaimed extends ethereum.Event {
  get params(): nftClaimed__Params {
    return new nftClaimed__Params(this);
  }
}

export class nftClaimed__Params {
  _event: nftClaimed;

  constructor(event: nftClaimed) {
    this._event = event;
  }

  get nftId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get redeemId(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get creator(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class Mint__fetchNFTsCreatedResultValue0Struct extends ethereum.Tuple {
  get tokenId(): BigInt {
    return this[0].toBigInt();
  }

  get contractAddress(): Address {
    return this[1].toAddress();
  }

  get redeemerAddress(): Address {
    return this[2].toAddress();
  }
}

export class Mint__fetchRedemptionTokensResultValue0Struct extends ethereum.Tuple {
  get redeemAmount(): BigInt {
    return this[0].toBigInt();
  }

  get contractAddress(): Address {
    return this[1].toAddress();
  }
}

export class Mint extends ethereum.SmartContract {
  static bind(address: Address): Mint {
    return new Mint("Mint", address);
  }

  DEV(): Bytes {
    let result = super.call("DEV", "DEV():(bytes32)", []);

    return result[0].toBytes();
  }

  try_DEV(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("DEV", "DEV():(bytes32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  NFTADD(): Bytes {
    let result = super.call("NFTADD", "NFTADD():(bytes32)", []);

    return result[0].toBytes();
  }

  try_NFTADD(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("NFTADD", "NFTADD():(bytes32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  PROXY_ROLE(): Bytes {
    let result = super.call("PROXY_ROLE", "PROXY_ROLE():(bytes32)", []);

    return result[0].toBytes();
  }

  try_PROXY_ROLE(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("PROXY_ROLE", "PROXY_ROLE():(bytes32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  REWARDS(): Bytes {
    let result = super.call("REWARDS", "REWARDS():(bytes32)", []);

    return result[0].toBytes();
  }

  try_REWARDS(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("REWARDS", "REWARDS():(bytes32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  availableNfts(param0: BigInt): BigInt {
    let result = super.call(
      "availableNfts",
      "availableNfts(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );

    return result[0].toBigInt();
  }

  try_availableNfts(param0: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "availableNfts",
      "availableNfts(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  eRC20Count(): BigInt {
    let result = super.call("eRC20Count", "eRC20Count():(uint256)", []);

    return result[0].toBigInt();
  }

  try_eRC20Count(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("eRC20Count", "eRC20Count():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  fetchNFTsCreated(): Array<Mint__fetchNFTsCreatedResultValue0Struct> {
    let result = super.call(
      "fetchNFTsCreated",
      "fetchNFTsCreated():((uint256,address,address)[])",
      []
    );

    return result[0].toTupleArray<Mint__fetchNFTsCreatedResultValue0Struct>();
  }

  try_fetchNFTsCreated(): ethereum.CallResult<
    Array<Mint__fetchNFTsCreatedResultValue0Struct>
  > {
    let result = super.tryCall(
      "fetchNFTsCreated",
      "fetchNFTsCreated():((uint256,address,address)[])",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTupleArray<Mint__fetchNFTsCreatedResultValue0Struct>()
    );
  }

  fetchNFTsCreatedCount(): BigInt {
    let result = super.call(
      "fetchNFTsCreatedCount",
      "fetchNFTsCreatedCount():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_fetchNFTsCreatedCount(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "fetchNFTsCreatedCount",
      "fetchNFTsCreatedCount():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  fetchRedemptionTokens(): Array<
    Mint__fetchRedemptionTokensResultValue0Struct
  > {
    let result = super.call(
      "fetchRedemptionTokens",
      "fetchRedemptionTokens():((uint256,address)[])",
      []
    );

    return result[0].toTupleArray<
      Mint__fetchRedemptionTokensResultValue0Struct
    >();
  }

  try_fetchRedemptionTokens(): ethereum.CallResult<
    Array<Mint__fetchRedemptionTokensResultValue0Struct>
  > {
    let result = super.tryCall(
      "fetchRedemptionTokens",
      "fetchRedemptionTokens():((uint256,address)[])",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTupleArray<Mint__fetchRedemptionTokensResultValue0Struct>()
    );
  }

  nftsRedeemed(): BigInt {
    let result = super.call("nftsRedeemed", "nftsRedeemed():(uint256)", []);

    return result[0].toBigInt();
  }

  try_nftsRedeemed(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("nftsRedeemed", "nftsRedeemed():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  nftsRemaining(): BigInt {
    let result = super.call("nftsRemaining", "nftsRemaining():(uint256)", []);

    return result[0].toBigInt();
  }

  try_nftsRemaining(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "nftsRemaining",
      "nftsRemaining():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  onERC1155Received(
    param0: Address,
    param1: Address,
    param2: BigInt,
    param3: BigInt,
    param4: Bytes
  ): Bytes {
    let result = super.call(
      "onERC1155Received",
      "onERC1155Received(address,address,uint256,uint256,bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
        ethereum.Value.fromUnsignedBigInt(param3),
        ethereum.Value.fromBytes(param4)
      ]
    );

    return result[0].toBytes();
  }

  try_onERC1155Received(
    param0: Address,
    param1: Address,
    param2: BigInt,
    param3: BigInt,
    param4: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "onERC1155Received",
      "onERC1155Received(address,address,uint256,uint256,bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
        ethereum.Value.fromUnsignedBigInt(param3),
        ethereum.Value.fromBytes(param4)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  onERC721Received(
    param0: Address,
    param1: Address,
    param2: BigInt,
    param3: Bytes
  ): Bytes {
    let result = super.call(
      "onERC721Received",
      "onERC721Received(address,address,uint256,bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
        ethereum.Value.fromBytes(param3)
      ]
    );

    return result[0].toBytes();
  }

  try_onERC721Received(
    param0: Address,
    param1: Address,
    param2: BigInt,
    param3: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "onERC721Received",
      "onERC721Received(address,address,uint256,bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
        ethereum.Value.fromBytes(param3)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  redeemForNft(redeemId: BigInt): boolean {
    let result = super.call("redeemForNft", "redeemForNft(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(redeemId)
    ]);

    return result[0].toBoolean();
  }

  try_redeemForNft(redeemId: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("redeemForNft", "redeemForNft(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(redeemId)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  resetRedemptionToken(redeemAmount: BigInt, contractAdd: Address): boolean {
    let result = super.call(
      "resetRedemptionToken",
      "resetRedemptionToken(uint256,address):(bool)",
      [
        ethereum.Value.fromUnsignedBigInt(redeemAmount),
        ethereum.Value.fromAddress(contractAdd)
      ]
    );

    return result[0].toBoolean();
  }

  try_resetRedemptionToken(
    redeemAmount: BigInt,
    contractAdd: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "resetRedemptionToken",
      "resetRedemptionToken(uint256,address):(bool)",
      [
        ethereum.Value.fromUnsignedBigInt(redeemAmount),
        ethereum.Value.fromAddress(contractAdd)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  roleAdd(): Address {
    let result = super.call("roleAdd", "roleAdd():(address)", []);

    return result[0].toAddress();
  }

  try_roleAdd(): ethereum.CallResult<Address> {
    let result = super.tryCall("roleAdd", "roleAdd():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  setNewRedemption(redeemAmount: BigInt, contractAdd: Address): boolean {
    let result = super.call(
      "setNewRedemption",
      "setNewRedemption(uint256,address):(bool)",
      [
        ethereum.Value.fromUnsignedBigInt(redeemAmount),
        ethereum.Value.fromAddress(contractAdd)
      ]
    );

    return result[0].toBoolean();
  }

  try_setNewRedemption(
    redeemAmount: BigInt,
    contractAdd: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "setNewRedemption",
      "setNewRedemption(uint256,address):(bool)",
      [
        ethereum.Value.fromUnsignedBigInt(redeemAmount),
        ethereum.Value.fromAddress(contractAdd)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  setNftCount(totalCount: BigInt): boolean {
    let result = super.call("setNftCount", "setNftCount(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(totalCount)
    ]);

    return result[0].toBoolean();
  }

  try_setNftCount(totalCount: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("setNftCount", "setNftCount(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(totalCount)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  tokensClaimed(param0: BigInt): BigInt {
    let result = super.call(
      "tokensClaimed",
      "tokensClaimed(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );

    return result[0].toBigInt();
  }

  try_tokensClaimed(param0: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "tokensClaimed",
      "tokensClaimed(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get role(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class OnERC1155ReceivedCall extends ethereum.Call {
  get inputs(): OnERC1155ReceivedCall__Inputs {
    return new OnERC1155ReceivedCall__Inputs(this);
  }

  get outputs(): OnERC1155ReceivedCall__Outputs {
    return new OnERC1155ReceivedCall__Outputs(this);
  }
}

export class OnERC1155ReceivedCall__Inputs {
  _call: OnERC1155ReceivedCall;

  constructor(call: OnERC1155ReceivedCall) {
    this._call = call;
  }

  get value0(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get value1(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get value2(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get value3(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get value4(): Bytes {
    return this._call.inputValues[4].value.toBytes();
  }
}

export class OnERC1155ReceivedCall__Outputs {
  _call: OnERC1155ReceivedCall;

  constructor(call: OnERC1155ReceivedCall) {
    this._call = call;
  }

  get value0(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class RedeemForNftCall extends ethereum.Call {
  get inputs(): RedeemForNftCall__Inputs {
    return new RedeemForNftCall__Inputs(this);
  }

  get outputs(): RedeemForNftCall__Outputs {
    return new RedeemForNftCall__Outputs(this);
  }
}

export class RedeemForNftCall__Inputs {
  _call: RedeemForNftCall;

  constructor(call: RedeemForNftCall) {
    this._call = call;
  }

  get redeemId(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class RedeemForNftCall__Outputs {
  _call: RedeemForNftCall;

  constructor(call: RedeemForNftCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class ResetRedemptionTokenCall extends ethereum.Call {
  get inputs(): ResetRedemptionTokenCall__Inputs {
    return new ResetRedemptionTokenCall__Inputs(this);
  }

  get outputs(): ResetRedemptionTokenCall__Outputs {
    return new ResetRedemptionTokenCall__Outputs(this);
  }
}

export class ResetRedemptionTokenCall__Inputs {
  _call: ResetRedemptionTokenCall;

  constructor(call: ResetRedemptionTokenCall) {
    this._call = call;
  }

  get redeemAmount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get contractAdd(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class ResetRedemptionTokenCall__Outputs {
  _call: ResetRedemptionTokenCall;

  constructor(call: ResetRedemptionTokenCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class SetNewRedemptionCall extends ethereum.Call {
  get inputs(): SetNewRedemptionCall__Inputs {
    return new SetNewRedemptionCall__Inputs(this);
  }

  get outputs(): SetNewRedemptionCall__Outputs {
    return new SetNewRedemptionCall__Outputs(this);
  }
}

export class SetNewRedemptionCall__Inputs {
  _call: SetNewRedemptionCall;

  constructor(call: SetNewRedemptionCall) {
    this._call = call;
  }

  get redeemAmount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get contractAdd(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class SetNewRedemptionCall__Outputs {
  _call: SetNewRedemptionCall;

  constructor(call: SetNewRedemptionCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class SetNftCountCall extends ethereum.Call {
  get inputs(): SetNftCountCall__Inputs {
    return new SetNftCountCall__Inputs(this);
  }

  get outputs(): SetNftCountCall__Outputs {
    return new SetNftCountCall__Outputs(this);
  }
}

export class SetNftCountCall__Inputs {
  _call: SetNftCountCall;

  constructor(call: SetNftCountCall) {
    this._call = call;
  }

  get totalCount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class SetNftCountCall__Outputs {
  _call: SetNftCountCall;

  constructor(call: SetNftCountCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}
